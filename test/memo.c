/****************************** (C) COPYRIGHT 2016 *******************************
 *
 *  	功能：测试堆栈等一些内存问题
 * 
 ********************************************************************************/

#include <stdio.h>

int tmp1 = 100;
int tmp2 = 200;
 
int g[10] = {1,2,3};
/*************************************************
	Function: 		main
	Description: 	主函数
	Calls: 			scanf	printf
	Called By:		编译器
	Input: 			无
	Output: 		无
	Return: 		0
*************************************************/
int main(void)
{
	int i;
	int j;
	const int c = 100;
	char a[] = "hello";	//数组只有在声明初始化时可以这样赋值，编译器会将分配一块栈空间让a指向它。
	char *p = "hello world";	//p在任何时候都可以赋值，实际指向的是一块代码区域，只读不可写。
	printf("a:%s\t%p\n", a, a);	//指针常量指向的地址的值，以及地址，a事指针指向的这个区域是个栈空间。	“栈”
	printf("a:%s\t%p\n", a, &a);	//指针常量指向的地址的值，以及地址，常量无法获取常量所在的地址，a就代表这个常量本身，编译器编译的时候已经替换为常量了。“栈”
	printf("g:%p\t%p\n", g, &g);	
	printf("p:%s\t%p\n", p, p);	//指针变量所指向的地址的值，这边指针变量实际是指向代码段的，属于只读区域，因此p指向的空间中的值无法改变，但p可以改变。“代码段”
	printf("p:%s\t%p\n", p, &p);	//指针变量所指向的地址的值，&p可以追溯到指针变量的地址，实际存在于栈中。“栈”
	printf("c:%d\t%p\n", c, &c);
	printf("i:%d\t%p\n", i, &i);	//i是一个局部变量，i存在于栈中，&i获得i的地址。							“栈”
	printf("j:%d\t%p\n", j, &j);	//i是一个局部变量，i存在于栈中，&i获得i的地址。							“栈”
	printf("tmp1:%d\t%p\n", tmp1, &tmp1);
	
	p = "go world";
	i = 10;
	printf("p:%s\t%p\n", p, p);	//同上面一样，指针变量p是一个变量，因此可以任意改变它的指向，这边指向了另一个，“代码段”。
	printf("p:%s\t%p\n", p, &p);	//指针变量所指向的地址的值，&p可以追溯到指针变量的地址，实际存在于栈中。“栈”

	printf("i:%d\t%p\n", i, &i);
	int k;
	printf("k:%d\t%p\n", k, &k);
	// c = 0;
}


